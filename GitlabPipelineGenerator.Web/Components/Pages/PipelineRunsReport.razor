@page "/reports/pipeline-runs"
@using GitlabPipelineGenerator.Web.Models
@using GitlabPipelineGenerator.Web.Services
@inject IJSRuntime JSRuntime
@inject LoadingService LoadingService

<PageTitle>Pipeline runs by date range</PageTitle>

<h1>Pipeline runs by date range</h1>

<div class="card">
    <div class="card-body">
        <p>Generate a report showing pipeline run counts by project within a date range.</p>
        <div class="mb-3">
            <label class="form-label">Start Date:</label>
            <input type="date" class="form-control" @bind="startDate" />
        </div>
        <div class="mb-3">
            <label class="form-label">End Date:</label>
            <input type="date" class="form-control" @bind="endDate" />
        </div>
        <button class="btn btn-primary" @onclick="GeneratePipelineRunsReport" disabled="@isGeneratingPipelines">
            @if (isGeneratingPipelines)
            {
                <span class="spinner-border spinner-border-sm" role="status"></span>
                <span>Generating...</span>
            }
            else
            {
                <span>Generate Report</span>
            }
        </button>
    </div>
</div>

@if (pipelineRunsReport != null)
{
    <div class="mt-4">
        <p><strong>Top-level Group:</strong> @pipelineRunsReport.GroupName</p>
        <p><strong>Date Range:</strong> @pipelineRunsReport.StartDate.ToString("yyyy-MM-dd") to @pipelineRunsReport.EndDate.ToString("yyyy-MM-dd")</p>
        
        @foreach (var group in pipelineRunsReport.Groups.OrderBy(g => g.GroupPath))
        {
            <div class="mb-4">
                <h3>@group.GroupName (@group.GroupPath)</h3>
                @if (group.Projects.Any())
                {
                    <table class="table table-striped">
                        <thead>
                            <tr>
                                <th>Project Name</th>
                                <th>Full Path</th>
                                <th>Pipeline Runs</th>
                            </tr>
                        </thead>
                        <tbody>
                            @foreach (var project in group.Projects.OrderBy(p => p.FullPath))
                            {
                                <tr>
                                    <td>@project.Name</td>
                                    <td>@project.FullPath</td>
                                    <td>@project.PipelineCount</td>
                                </tr>
                            }
                        </tbody>
                    </table>
                }
                else
                {
                    <p class="text-muted">No projects found in this group.</p>
                }
            </div>
        }
        
        <div class="mt-3">
            <button class="btn btn-success" @onclick="ExportPipelineRunsReport">Export to CSV</button>
        </div>
    </div>
}

@if (!string.IsNullOrEmpty(errorMessage))
{
    <div class="alert alert-danger mt-3">@errorMessage</div>
}

@code {
    private PipelineRunsReportModel? pipelineRunsReport;
    private bool isGeneratingPipelines = false;
    private string? errorMessage;
    private DateTime startDate = DateTime.Today.AddDays(-30);
    private DateTime endDate = DateTime.Today;

    private async Task GeneratePipelineRunsReport()
    {
        isGeneratingPipelines = true;
        errorMessage = null;
        LoadingService.SetLoading(true, "Loading GitLab settings...");

        try
        {
            var json = await JSRuntime.InvokeAsync<string>("localStorage.getItem", "gitlab-settings");
            if (string.IsNullOrEmpty(json))
            {
                errorMessage = "No GitLab settings found. Please configure GitLab connection in Settings.";
                return;
            }

            var settings = System.Text.Json.JsonSerializer.Deserialize<GitLabConnectionModel>(json);
            if (settings == null || string.IsNullOrEmpty(settings.Token) || string.IsNullOrEmpty(settings.DefaultGroupId))
            {
                errorMessage = "GitLab token or default group ID not configured. Please check Settings.";
                return;
            }

            LoadingService.SetLoading(true, "Connecting to GitLab...");
            var client = new GitlabPipelineGenerator.GitLabApiClient.GitLabClient(settings.ServerUrl, settings.Token);
            
            LoadingService.SetLoading(true, "Loading group information...");
            var group = await client.GetGroupAsync(settings.DefaultGroupId);
            
            var report = new PipelineRunsReportModel 
            { 
                GroupName = group.Name,
                StartDate = startDate,
                EndDate = endDate
            };
            
            LoadingService.SetLoading(true, "Loading subgroups and projects...");
            var subgroups = await client.GetSubgroupsAsync(settings.DefaultGroupId, 100, 1);
            
            // Add main group projects
            var mainGroupProjects = await client.GetGroupProjectsAsync(settings.DefaultGroupId, 100, 1);
            if (mainGroupProjects.Any())
            {
                var mainGroup = new GroupPipelineRuns
                {
                    GroupName = group.Name,
                    GroupPath = group.FullPath
                };
                
                foreach (var project in mainGroupProjects)
                {
                    LoadingService.SetLoading(true, $"Loading pipelines for {project.Name}...");
                    try
                    {
                        var pipelines = await client.GetProjectPipelinesAsync(project.Id.ToString(), startDate, endDate);
                        mainGroup.Projects.Add(new ProjectPipelineRuns
                        {
                            Name = project.Name,
                            FullPath = project.PathWithNamespace,
                            PipelineCount = pipelines.Count
                        });
                    }
                    catch
                    {
                        mainGroup.Projects.Add(new ProjectPipelineRuns
                        {
                            Name = project.Name,
                            FullPath = project.PathWithNamespace,
                            PipelineCount = 0
                        });
                    }
                }
                report.Groups.Add(mainGroup);
            }
            
            // Add subgroup projects
            foreach (var subgroup in subgroups)
            {
                var groupProjects = await client.GetGroupProjectsAsync(subgroup.Id.ToString(), 100, 1);
                if (groupProjects.Any())
                {
                    var groupRuns = new GroupPipelineRuns
                    {
                        GroupName = subgroup.Name,
                        GroupPath = subgroup.FullPath
                    };
                    
                    foreach (var project in groupProjects)
                    {
                        LoadingService.SetLoading(true, $"Loading pipelines for {project.Name}...");
                        try
                        {
                            var pipelines = await client.GetProjectPipelinesAsync(project.Id.ToString(), startDate, endDate);
                            groupRuns.Projects.Add(new ProjectPipelineRuns
                            {
                                Name = project.Name,
                                FullPath = project.PathWithNamespace,
                                PipelineCount = pipelines.Count
                            });
                        }
                        catch
                        {
                            groupRuns.Projects.Add(new ProjectPipelineRuns
                            {
                                Name = project.Name,
                                FullPath = project.PathWithNamespace,
                                PipelineCount = 0
                            });
                        }
                    }
                    report.Groups.Add(groupRuns);
                }
            }
            
            pipelineRunsReport = report;
        }
        catch (Exception ex)
        {
            errorMessage = $"Error generating pipeline runs report: {ex.Message}";
        }
        finally
        {
            isGeneratingPipelines = false;
            LoadingService.SetLoading(false);
        }
    }

    private async Task ExportPipelineRunsReport()
    {
        if (pipelineRunsReport == null) return;

        var csv = new System.Text.StringBuilder();
        csv.AppendLine("Group Name,Group Path,Project Name,Project Path,Pipeline Count");
        
        foreach (var group in pipelineRunsReport.Groups.OrderBy(g => g.GroupPath))
        {
            foreach (var project in group.Projects.OrderBy(p => p.FullPath))
            {
                csv.AppendLine($"\"{group.GroupName}\",\"{group.GroupPath}\",\"{project.Name}\",\"{project.FullPath}\",{project.PipelineCount}");
            }
        }

        var fileName = $"gitlab-pipeline-runs-report-{pipelineRunsReport.StartDate:yyyyMMdd}-{pipelineRunsReport.EndDate:yyyyMMdd}.csv";
        await JSRuntime.InvokeVoidAsync("downloadFile", fileName, csv.ToString(), "text/csv");
    }
}